<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Reprodutor Offline PWA</title>
    <meta name="theme-color" content="#0f172a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- Manifesto PWA Melhorado e Codificado -->
    <link id="manifest-link" rel="manifest" href="">

    <style>
        /* Animações e ajustes finos */
        .slider-thumb::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
        }
        .album-art-spin {
            animation: spin 10s linear infinite;
        }
        .album-art-paused {
            animation-play-state: paused;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        /* Garante que o clique passe para o botão, não para o ícone */
        .pointer-events-none-child > * {
            pointer-events: none;
        }
        /* Área de toque maior para botões móveis */
        .touch-target {
            min-width: 44px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body class="bg-slate-900 text-white font-sans h-screen flex flex-col overflow-hidden">

    <!-- Topo: Header -->
    <header class="flex justify-between items-center p-4 bg-slate-800/50 backdrop-blur-md z-10 shrink-0">
        <div class="flex items-center gap-2">
            <i data-lucide="music" class="text-blue-400"></i>
            <h1 class="font-bold text-lg">Minhas Músicas</h1>
        </div>
        <button id="installBtn" class="hidden bg-blue-600 hover:bg-blue-500 text-xs px-3 py-2 rounded-full font-medium transition flex items-center gap-2 shadow-lg animate-pulse">
            <i data-lucide="download" class="w-4 h-4"></i>
            Instalar App
        </button>
    </header>

    <!-- Área Principal: Lista de Músicas -->
    <main class="flex-1 overflow-y-auto p-4 no-scrollbar relative" id="playlist-container">
        
        <!-- Estado Vazio -->
        <div id="empty-state" class="flex flex-col items-center justify-center h-full text-slate-500 text-center space-y-4">
            <i data-lucide="music-2" class="w-16 h-16 opacity-50"></i>
            <p>Nenhuma música adicionada.</p>
            <p class="text-sm">Toque no botão + para adicionar arquivos de áudio do seu dispositivo.</p>
            <p class="text-xs text-slate-600 mt-4 max-w-xs">Nota: Para instalar como App, use a opção "Adicionar à Tela Inicial" do seu navegador se o botão não aparecer.</p>
        </div>

        <!-- Lista de Músicas Renderizada via JS -->
        <ul id="song-list" class="space-y-2 pb-24">
            <!-- Itens serão injetados aqui -->
        </ul>
    </main>

    <!-- Player Fixo no Rodapé -->
    <footer class="bg-slate-800 border-t border-slate-700 p-4 fixed bottom-0 w-full z-20 backdrop-blur-lg bg-opacity-95 shadow-2xl">
        
        <!-- Controles de Progresso -->
        <div class="mb-2 flex items-center justify-between text-xs text-slate-400">
            <span id="current-time">0:00</span>
            <input type="range" id="progress-bar" value="0" max="100" class="mx-2 w-full h-1 bg-slate-600 rounded-lg appearance-none cursor-pointer">
            <span id="duration">0:00</span>
        </div>

        <!-- Informações da Música e Controles -->
        <div class="flex items-center justify-between">
            
            <!-- Info Música -->
            <div class="flex items-center gap-3 flex-1 min-w-0">
                <div class="w-10 h-10 bg-slate-700 rounded-full flex items-center justify-center overflow-hidden flex-shrink-0 relative border border-slate-600">
                    <img id="mini-cover" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%23475569'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3'/%3E%3C/svg%3E" class="w-full h-full object-cover opacity-80" alt="Capa">
                </div>
                <div class="truncate pr-2">
                    <h3 id="player-title" class="font-bold text-sm truncate text-white">Selecione uma música</h3>
                    <p id="player-artist" class="text-xs text-slate-400 truncate">Reprodutor Offline</p>
                </div>
            </div>

            <!-- Botões de Controle -->
            <div class="flex items-center gap-2 sm:gap-4 pl-1">
                <button id="prev-btn" class="text-slate-400 hover:text-white transition touch-target">
                    <i data-lucide="skip-back" class="w-6 h-6"></i>
                </button>
                
                <button id="play-pause-btn" class="w-12 h-12 bg-blue-500 hover:bg-blue-400 rounded-full flex items-center justify-center text-white shadow-lg transition transform active:scale-95 pointer-events-none-child touch-target">
                    <span id="play-icon-container" class="flex items-center justify-center">
                        <i data-lucide="play" class="w-6 h-6 fill-current ml-1"></i>
                    </span>
                    <span id="pause-icon-container" class="hidden flex items-center justify-center">
                        <i data-lucide="pause" class="w-6 h-6 fill-current"></i>
                    </span>
                </button>

                <button id="next-btn" class="text-slate-400 hover:text-white transition touch-target">
                    <i data-lucide="skip-forward" class="w-6 h-6"></i>
                </button>
            </div>
        </div>
    </footer>

    <!-- Botão Flutuante de Adicionar -->
    <label for="file-upload" class="fixed bottom-32 right-6 w-14 h-14 bg-indigo-600 hover:bg-indigo-500 rounded-full flex items-center justify-center shadow-xl cursor-pointer transition transform hover:scale-110 z-30 active:scale-90">
        <i data-lucide="plus" class="w-8 h-8 text-white"></i>
        <input type="file" id="file-upload" multiple accept="audio/*" class="hidden">
    </label>

    <!-- Modal de Edição -->
    <div id="edit-modal" class="fixed inset-0 bg-black/90 hidden items-center justify-center z-50 p-4 backdrop-blur-sm">
        <div class="bg-slate-800 p-6 rounded-xl w-full max-w-sm shadow-2xl border border-slate-700 transform transition-all scale-100">
            <h2 class="text-xl font-bold mb-4 text-white flex items-center gap-2">
                <i data-lucide="pencil" class="w-5 h-5 text-blue-400"></i>
                Editar Música
            </h2>
            <div class="space-y-4">
                <div>
                    <label class="text-xs text-slate-400 mb-1 block">Título</label>
                    <input type="text" id="edit-title" class="w-full bg-slate-900 text-white p-3 rounded-lg border border-slate-600 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none transition">
                </div>
                <div>
                    <label class="text-xs text-slate-400 mb-1 block">Artista</label>
                    <input type="text" id="edit-artist" class="w-full bg-slate-900 text-white p-3 rounded-lg border border-slate-600 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none transition">
                </div>
            </div>
            <div class="flex justify-end gap-3 mt-6">
                <button id="cancel-edit" class="px-4 py-2 text-slate-300 hover:text-white transition">Cancelar</button>
                <button id="save-edit" class="px-6 py-2 bg-blue-600 hover:bg-blue-500 rounded-lg text-white font-medium shadow-lg transition">Salvar</button>
            </div>
        </div>
    </div>

    <!-- Elemento de áudio invisível -->
    <audio id="audio-element"></audio>

    <script>
        // --- 0. CONFIGURAÇÃO PWA & MANIFESTO ---
        // Gerar manifesto dinamicamente para garantir codificação correta
        const pwaManifest = {
            "name": "Music PWA",
            "short_name": "Player",
            "start_url": ".",
            "display": "standalone",
            "background_color": "#0f172a",
            "theme_color": "#0f172a",
            "orientation": "portrait",
            "icons": [
                {
                    "src": "https://cdn-icons-png.flaticon.com/512/3220/3220668.png",
                    "sizes": "512x512",
                    "type": "image/png",
                    "purpose": "any maskable"
                }
            ]
        };
        const stringManifest = JSON.stringify(pwaManifest);
        const blobManifest = new Blob([stringManifest], {type: 'application/json'});
        const manifestURL = URL.createObjectURL(blobManifest);
        document.querySelector('#manifest-link').setAttribute('href', manifestURL);

        // Tentativa de Registrar Service Worker (Necessário para Instalação Nativa)
        if ('serviceWorker' in navigator) {
            const swCode = `
                self.addEventListener('install', (e) => self.skipWaiting());
                self.addEventListener('activate', (e) => self.clients.claim());
                self.addEventListener('fetch', (e) => {
                    // Cache simples ou Network-first
                    e.respondWith(fetch(e.request).catch(() => new Response("Offline")));
                });
            `;
            const blobSW = new Blob([swCode], {type: 'application/javascript'});
            const swURL = URL.createObjectURL(blobSW);
            
            // Tenta registrar (pode falhar dependendo da política de segurança do navegador em Blob URLs)
            navigator.serviceWorker.register(swURL)
                .then(() => console.log('SW (Blob) Registrado'))
                .catch(err => console.log('SW Falhou (Normal em alguns hosts):', err));
        }

        // Variável para guardar o evento de instalação
        let deferredPrompt;
        const installBtn = document.getElementById('installBtn');

        window.addEventListener('beforeinstallprompt', (e) => {
            // Previne o Chrome de mostrar o prompt nativo imediatamente
            e.preventDefault();
            deferredPrompt = e;
            // Mostra nosso botão
            installBtn.classList.remove('hidden');
            installBtn.classList.add('flex');
        });

        installBtn.addEventListener('click', async () => {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                if (outcome === 'accepted') {
                    installBtn.classList.add('hidden');
                }
                deferredPrompt = null;
            } else {
                alert('Para instalar: Abra o menu do navegador (três pontinhos) e selecione "Adicionar à Tela Inicial" ou "Instalar Aplicativo".');
            }
        });

        // --- 1. CONFIGURAÇÃO DO BANCO DE DADOS (IndexedDB) ---
        const DB_NAME = 'MusicAppDB';
        const STORE_NAME = 'songs';
        let db;

        const initDB = () => {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);
                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                    }
                };
                request.onsuccess = (event) => {
                    db = event.target.result;
                    resolve(db);
                };
                request.onerror = (event) => reject('Erro ao abrir DB');
            });
        };

        const saveSong = (file) => {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                
                const nameParts = file.name.replace(/\.[^/.]+$/, "").split('-');
                const artist = nameParts.length > 1 ? nameParts[0].trim() : 'Artista Desconhecido';
                const title = nameParts.length > 1 ? nameParts[1].trim() : nameParts[0].trim();

                const song = {
                    title: title,
                    artist: artist,
                    file: file,
                    dateAdded: new Date()
                };
                
                const request = store.add(song);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject('Erro ao salvar');
            });
        };

        const getAllSongs = () => {
            return new Promise((resolve) => {
                if(!db) { resolve([]); return; }
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => resolve([]);
            });
        };

        const updateSongMetadata = (id, newTitle, newArtist) => {
            return new Promise((resolve) => {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get(id);
                request.onsuccess = () => {
                    const data = request.result;
                    data.title = newTitle;
                    data.artist = newArtist;
                    store.put(data).onsuccess = () => resolve();
                };
            });
        };

        const deleteSong = (id) => {
            return new Promise((resolve) => {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                store.delete(id).onsuccess = () => resolve();
            });
        };

        // --- 2. LÓGICA DO PLAYER & ESTADO ---
        let playlist = [];
        let currentIndex = -1;
        let isPlaying = false;
        const audio = document.getElementById('audio-element');

        // Elementos UI
        const playPauseBtn = document.getElementById('play-pause-btn');
        const playIconContainer = document.getElementById('play-icon-container');
        const pauseIconContainer = document.getElementById('pause-icon-container');
        const progressBar = document.getElementById('progress-bar');
        const currentTimeEl = document.getElementById('current-time');
        const durationEl = document.getElementById('duration');
        const titleEl = document.getElementById('player-title');
        const artistEl = document.getElementById('player-artist');
        const miniCover = document.getElementById('mini-cover');
        const songListEl = document.getElementById('song-list');
        const emptyState = document.getElementById('empty-state');
        
        // Modal de Edição
        const editModal = document.getElementById('edit-modal');
        const editTitleInput = document.getElementById('edit-title');
        const editArtistInput = document.getElementById('edit-artist');
        const saveEditBtn = document.getElementById('save-edit');
        const cancelEditBtn = document.getElementById('cancel-edit');
        let editingId = null;

        async function init() {
            try {
                await initDB();
                loadPlaylist();
            } catch (e) {
                console.error("Falha ao iniciar DB:", e);
                alert("Erro ao iniciar armazenamento. Alguns recursos podem não funcionar.");
            }
            
            // Setup Media Session API (Background Play - CRUCIAL PARA TELA APAGADA)
            if ('mediaSession' in navigator) {
                navigator.mediaSession.setActionHandler('play', () => audio.play());
                navigator.mediaSession.setActionHandler('pause', () => audio.pause());
                navigator.mediaSession.setActionHandler('previoustrack', playPrev);
                navigator.mediaSession.setActionHandler('nexttrack', playNext);
                navigator.mediaSession.setActionHandler('seekto', (details) => {
                    if (details.fastSeek && 'fastSeek' in audio) {
                        audio.fastSeek(details.seekTime);
                        return;
                    }
                    audio.currentTime = details.seekTime;
                });
            }

            lucide.createIcons();
        }

        async function loadPlaylist() {
            playlist = await getAllSongs();
            renderPlaylist();
        }

        function renderPlaylist() {
            songListEl.innerHTML = '';
            if (playlist.length === 0) {
                emptyState.classList.remove('hidden');
            } else {
                emptyState.classList.add('hidden');
                playlist.forEach((song, index) => {
                    const li = document.createElement('li');
                    li.className = `flex items-center justify-between p-3 rounded-lg bg-slate-800 hover:bg-slate-750 transition border border-slate-700 group ${index === currentIndex ? 'border-blue-500 bg-slate-750' : ''}`;
                    
                    li.innerHTML = `
                        <div class="flex items-center gap-3 flex-1 min-w-0 cursor-pointer" onclick="playSong(${index})">
                            <div class="w-10 h-10 rounded-full flex items-center justify-center bg-slate-900 text-slate-400 shrink-0">
                                ${index === currentIndex && isPlaying 
                                    ? '<i data-lucide="bar-chart-2" class="w-5 h-5 text-blue-500 animate-pulse"></i>' 
                                    : '<i data-lucide="music" class="w-5 h-5"></i>'}
                            </div>
                            <div class="truncate">
                                <h4 class="font-medium text-sm truncate ${index === currentIndex ? 'text-blue-400' : 'text-white'}">${song.title}</h4>
                                <p class="text-xs text-slate-400 truncate">${song.artist}</p>
                            </div>
                        </div>
                        <div class="flex items-center gap-1">
                            <!-- Botão Lápis com cor mais forte e z-index -->
                            <button onclick="openEditModal(${song.id})" class="p-3 text-slate-400 hover:text-blue-400 touch-target z-10" title="Editar">
                                <i data-lucide="pencil" class="w-5 h-5"></i>
                            </button>
                            <button onclick="removeSong(${song.id})" class="p-3 text-slate-400 hover:text-red-400 touch-target z-10" title="Apagar">
                                <i data-lucide="trash-2" class="w-5 h-5"></i>
                            </button>
                        </div>
                    `;
                    songListEl.appendChild(li);
                });
                // Recriar ícones após injetar HTML
                lucide.createIcons();
            }
        }

        function playSong(index) {
            if (index < 0 || index >= playlist.length) return;
            
            currentIndex = index;
            const song = playlist[currentIndex];
            
            if (audio.src && audio.src.startsWith('blob:')) {
                URL.revokeObjectURL(audio.src);
            }

            const fileUrl = URL.createObjectURL(song.file);
            audio.src = fileUrl;
            
            const playPromise = audio.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    updateMediaSession(song);
                }).catch(error => {
                    console.warn("Autoplay bloqueado ou erro:", error);
                    isPlaying = false;
                    updatePlayPauseIcon();
                });
            }

            updatePlayerUI(song);
            renderPlaylist(); 
        }

        function togglePlay() {
            if (!audio.src && playlist.length > 0) {
                playSong(0);
                return;
            }
            if (audio.src) {
                if (audio.paused) {
                    audio.play().catch(e => console.error(e));
                } else {
                    audio.pause();
                }
            }
        }

        function playNext() {
            if (playlist.length === 0) return;
            let nextIndex = currentIndex + 1;
            if (nextIndex >= playlist.length) nextIndex = 0;
            playSong(nextIndex);
        }

        function playPrev() {
            if (playlist.length === 0) return;
            let prevIndex = currentIndex - 1;
            if (prevIndex < 0) prevIndex = playlist.length - 1;
            playSong(prevIndex);
        }

        function updateMediaSession(song) {
            if ('mediaSession' in navigator) {
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: song.title,
                    artist: song.artist,
                    artwork: [
                        { src: 'https://cdn-icons-png.flaticon.com/512/3220/3220668.png', sizes: '512x512', type: 'image/png' }
                    ]
                });
            }
        }

        function updatePlayPauseIcon() {
            if (isPlaying) {
                playIconContainer.classList.add('hidden');
                pauseIconContainer.classList.remove('hidden');
                miniCover.classList.add('album-art-spin');
                miniCover.classList.remove('album-art-paused');
            } else {
                playIconContainer.classList.remove('hidden');
                pauseIconContainer.classList.add('hidden');
                miniCover.classList.add('album-art-paused');
            }
        }

        // Eventos de Áudio Robusto
        audio.addEventListener('play', () => {
            isPlaying = true;
            updatePlayPauseIcon();
            // Re-renderizar lista para mostrar ícone animado tocando
            const currentItem = songListEl.children[currentIndex];
            if(currentItem) {
                 // Pequena otimização para não recriar tudo sempre
                 const iconContainer = currentItem.querySelector('div.rounded-full');
                 if(iconContainer) {
                     iconContainer.innerHTML = '<i data-lucide="bar-chart-2" class="w-5 h-5 text-blue-500 animate-pulse"></i>';
                     lucide.createIcons();
                 }
            }
        });

        audio.addEventListener('pause', () => {
            isPlaying = false;
            updatePlayPauseIcon();
            // Reverter ícone na lista
            const currentItem = songListEl.children[currentIndex];
            if(currentItem) {
                 const iconContainer = currentItem.querySelector('div.rounded-full');
                 if(iconContainer) {
                     iconContainer.innerHTML = '<i data-lucide="music" class="w-5 h-5"></i>';
                     lucide.createIcons();
                 }
            }
        });

        audio.addEventListener('ended', playNext);
        audio.addEventListener('error', (e) => {
            console.error("Erro no áudio:", e);
            isPlaying = false;
            updatePlayPauseIcon();
        });

        audio.addEventListener('timeupdate', () => {
            if(audio.duration && !isNaN(audio.duration)) {
                const progress = (audio.currentTime / audio.duration) * 100;
                progressBar.value = progress;
                currentTimeEl.textContent = formatTime(audio.currentTime);
                durationEl.textContent = formatTime(audio.duration);
            }
        });

        progressBar.addEventListener('input', (e) => {
            if (audio.duration) {
                const time = (progressBar.value / 100) * audio.duration;
                audio.currentTime = time;
            }
        });

        // --- LÓGICA DE EDIÇÃO ---
        window.openEditModal = (id) => {
            const song = playlist.find(s => s.id === id);
            if (!song) return;

            editingId = id;
            editTitleInput.value = song.title;
            editArtistInput.value = song.artist;
            editModal.classList.remove('hidden');
            editModal.classList.add('flex');
        };

        const closeEditModal = () => {
            editModal.classList.add('hidden');
            editModal.classList.remove('flex');
            editingId = null;
        };

        saveEditBtn.addEventListener('click', async () => {
            if (editingId !== null) {
                const newTitle = editTitleInput.value || 'Sem Título';
                const newArtist = editArtistInput.value || 'Desconhecido';
                
                await updateSongMetadata(editingId, newTitle, newArtist);
                await loadPlaylist();
                
                if (playlist[currentIndex] && playlist[currentIndex].id === editingId) {
                    updatePlayerUI(playlist[currentIndex]);
                    updateMediaSession(playlist[currentIndex]);
                }
                
                closeEditModal();
            }
        });

        cancelEditBtn.addEventListener('click', closeEditModal);
        // Fechar modal ao clicar fora
        editModal.addEventListener('click', (e) => {
            if (e.target === editModal) closeEditModal();
        });

        window.removeSong = async (id) => {
            if(confirm('Tem certeza que deseja apagar esta música?')) {
                await deleteSong(id);
                if (playlist[currentIndex] && playlist[currentIndex].id === id) {
                    audio.pause();
                    audio.src = '';
                    currentIndex = -1;
                    updatePlayerUI({title: 'Selecione uma música', artist: 'Reprodutor Offline'});
                }
                loadPlaylist();
            }
        };

        // --- UPLOAD ---
        document.getElementById('file-upload').addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;

            const header = document.querySelector('h1');
            const originalText = header.textContent;
            header.textContent = "Salvando...";

            for (const file of files) {
                try {
                    await saveSong(file);
                } catch (err) {
                    console.error("Erro ao salvar:", file.name);
                }
            }
            
            header.textContent = originalText;
            await loadPlaylist();
        });

        function updatePlayerUI(song) {
            titleEl.textContent = song.title;
            artistEl.textContent = song.artist;
        }

        function formatTime(seconds) {
            if (isNaN(seconds)) return "0:00";
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
        }

        playPauseBtn.addEventListener('click', togglePlay);
        document.getElementById('next-btn').addEventListener('click', playNext);
        document.getElementById('prev-btn').addEventListener('click', playPrev);

        // Iniciar
        init();

    </script>
</body>
</html>
